// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: camera_cloud.proto

/*
	package proto is a generated protocol buffer package.

	It is generated from these files:
		camera_cloud.proto
		camera_core.proto

	It has these top-level messages:
		RegisterCameraRequest
		GetCameraRequest
		DeleteCameraRequest
		UpdateCameraRequest
		GetCamerasListResponse
		CameraItemResponse
		Camera
		CreateCameraStreamRequest
		GetCameraStreamsListRequest
		CompleteCameraStreamRequest
		Stream
		Streams
		UpdateStateCameraRequest
		RTMPPoint
		Preview
		Output
		Encode
		Point
		Picture
		Curve
		Notification
		AudioDevice
		AudioDevices
		Calibration
		Calibrations
		HDR
		Storage
		WifiNetwork
		Network
		Software
		FOV
		State
*/
package proto

import proto1 "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"
import _ "google.golang.org/genproto/googleapis/api/annotations"
import _ "github.com/golang/protobuf/ptypes/timestamp"
import google_protobuf2 "github.com/golang/protobuf/ptypes/empty"
import _ "github.com/gogo/protobuf/gogoproto"
import _ "github.com/mwitkow/go-proto-validators"

import time "time"

import context "golang.org/x/net/context"
import grpc "google.golang.org/grpc"

import types "github.com/gogo/protobuf/types"

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto1.Marshal
var _ = fmt.Errorf
var _ = math.Inf
var _ = time.Kitchen

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto1.ProtoPackageIsVersion2 // please upgrade the proto package

type Projection int32

const (
	Projection_EQUIRECTANGULAR        Projection = 0
	Projection_SMOOTH_EQUIRECTANGULAR Projection = 1
)

var Projection_name = map[int32]string{
	0: "EQUIRECTANGULAR",
	1: "SMOOTH_EQUIRECTANGULAR",
}
var Projection_value = map[string]int32{
	"EQUIRECTANGULAR":        0,
	"SMOOTH_EQUIRECTANGULAR": 1,
}

func (x Projection) String() string {
	return proto1.EnumName(Projection_name, int32(x))
}
func (Projection) EnumDescriptor() ([]byte, []int) { return fileDescriptorCameraCloud, []int{0} }

type StereoMode int32

const (
	StereoMode_MONO StereoMode = 0
	StereoMode_TB   StereoMode = 1
)

var StereoMode_name = map[int32]string{
	0: "MONO",
	1: "TB",
}
var StereoMode_value = map[string]int32{
	"MONO": 0,
	"TB":   1,
}

func (x StereoMode) String() string {
	return proto1.EnumName(StereoMode_name, int32(x))
}
func (StereoMode) EnumDescriptor() ([]byte, []int) { return fileDescriptorCameraCloud, []int{1} }

type IngestionType int32

const (
	IngestionType_RTMP IngestionType = 0
)

var IngestionType_name = map[int32]string{
	0: "RTMP",
}
var IngestionType_value = map[string]int32{
	"RTMP": 0,
}

func (x IngestionType) String() string {
	return proto1.EnumName(IngestionType_name, int32(x))
}
func (IngestionType) EnumDescriptor() ([]byte, []int) { return fileDescriptorCameraCloud, []int{2} }

type Stream_Status int32

const (
	Stream_OFF_AIR Stream_Status = 0
	Stream_PREVIEW Stream_Status = 1
	Stream_ON_AIR  Stream_Status = 2
)

var Stream_Status_name = map[int32]string{
	0: "OFF_AIR",
	1: "PREVIEW",
	2: "ON_AIR",
}
var Stream_Status_value = map[string]int32{
	"OFF_AIR": 0,
	"PREVIEW": 1,
	"ON_AIR":  2,
}

func (x Stream_Status) String() string {
	return proto1.EnumName(Stream_Status_name, int32(x))
}
func (Stream_Status) EnumDescriptor() ([]byte, []int) { return fileDescriptorCameraCloud, []int{10, 0} }

type RegisterCameraRequest struct {
	Id   string `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	Name string `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty"`
}

func (m *RegisterCameraRequest) Reset()                    { *m = RegisterCameraRequest{} }
func (m *RegisterCameraRequest) String() string            { return proto1.CompactTextString(m) }
func (*RegisterCameraRequest) ProtoMessage()               {}
func (*RegisterCameraRequest) Descriptor() ([]byte, []int) { return fileDescriptorCameraCloud, []int{0} }

func (m *RegisterCameraRequest) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *RegisterCameraRequest) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

type GetCameraRequest struct {
	Id string `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
}

func (m *GetCameraRequest) Reset()                    { *m = GetCameraRequest{} }
func (m *GetCameraRequest) String() string            { return proto1.CompactTextString(m) }
func (*GetCameraRequest) ProtoMessage()               {}
func (*GetCameraRequest) Descriptor() ([]byte, []int) { return fileDescriptorCameraCloud, []int{1} }

func (m *GetCameraRequest) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

type DeleteCameraRequest struct {
	Id string `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
}

func (m *DeleteCameraRequest) Reset()                    { *m = DeleteCameraRequest{} }
func (m *DeleteCameraRequest) String() string            { return proto1.CompactTextString(m) }
func (*DeleteCameraRequest) ProtoMessage()               {}
func (*DeleteCameraRequest) Descriptor() ([]byte, []int) { return fileDescriptorCameraCloud, []int{2} }

func (m *DeleteCameraRequest) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

type UpdateCameraRequest struct {
	Id   string `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	Name string `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty"`
}

func (m *UpdateCameraRequest) Reset()                    { *m = UpdateCameraRequest{} }
func (m *UpdateCameraRequest) String() string            { return proto1.CompactTextString(m) }
func (*UpdateCameraRequest) ProtoMessage()               {}
func (*UpdateCameraRequest) Descriptor() ([]byte, []int) { return fileDescriptorCameraCloud, []int{3} }

func (m *UpdateCameraRequest) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *UpdateCameraRequest) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

type GetCamerasListResponse struct {
	Items []*CameraItemResponse `protobuf:"bytes,1,rep,name=items" json:"items,omitempty"`
}

func (m *GetCamerasListResponse) Reset()         { *m = GetCamerasListResponse{} }
func (m *GetCamerasListResponse) String() string { return proto1.CompactTextString(m) }
func (*GetCamerasListResponse) ProtoMessage()    {}
func (*GetCamerasListResponse) Descriptor() ([]byte, []int) {
	return fileDescriptorCameraCloud, []int{4}
}

func (m *GetCamerasListResponse) GetItems() []*CameraItemResponse {
	if m != nil {
		return m.Items
	}
	return nil
}

type CameraItemResponse struct {
	Id              string            `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	Name            string            `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty"`
	RegisteredAt    *time.Time        `protobuf:"bytes,4,opt,name=registered_at,json=registeredAt,stdtime" json:"registered_at,omitempty"`
	IsConnected     bool              `protobuf:"varint,5,opt,name=is_connected,json=isConnected,proto3" json:"is_connected,omitempty"`
	IsOnAir         bool              `protobuf:"varint,6,opt,name=is_on_air,json=isOnAir,proto3" json:"is_on_air,omitempty"`
	PreviewImageUrl string            `protobuf:"bytes,7,opt,name=preview_image_url,json=previewImageUrl,proto3" json:"preview_image_url,omitempty"`
	OutputType      Output_OutputType `protobuf:"varint,8,opt,name=output_type,json=outputType,proto3,enum=proto.Output_OutputType" json:"output_type,omitempty"`
}

func (m *CameraItemResponse) Reset()                    { *m = CameraItemResponse{} }
func (m *CameraItemResponse) String() string            { return proto1.CompactTextString(m) }
func (*CameraItemResponse) ProtoMessage()               {}
func (*CameraItemResponse) Descriptor() ([]byte, []int) { return fileDescriptorCameraCloud, []int{5} }

func (m *CameraItemResponse) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *CameraItemResponse) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *CameraItemResponse) GetRegisteredAt() *time.Time {
	if m != nil {
		return m.RegisteredAt
	}
	return nil
}

func (m *CameraItemResponse) GetIsConnected() bool {
	if m != nil {
		return m.IsConnected
	}
	return false
}

func (m *CameraItemResponse) GetIsOnAir() bool {
	if m != nil {
		return m.IsOnAir
	}
	return false
}

func (m *CameraItemResponse) GetPreviewImageUrl() string {
	if m != nil {
		return m.PreviewImageUrl
	}
	return ""
}

func (m *CameraItemResponse) GetOutputType() Output_OutputType {
	if m != nil {
		return m.OutputType
	}
	return Output_OFF
}

type Camera struct {
	Id           string     `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	Name         string     `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty" gorm:"size:255"`
	OwnerId      uint32     `protobuf:"varint,3,opt,name=owner_id,json=ownerId,proto3" json:"owner_id,omitempty" gorm:"index"`
	RegisteredAt *time.Time `protobuf:"bytes,4,opt,name=registered_at,json=registeredAt,stdtime" json:"registered_at,omitempty"`
	IsConnected  bool       `protobuf:"varint,5,opt,name=is_connected,json=isConnected,proto3" json:"is_connected,omitempty"`
	IsOnAir      bool       `protobuf:"varint,6,opt,name=is_on_air,json=isOnAir,proto3" json:"is_on_air,omitempty"`
	Stream       *Stream    `protobuf:"bytes,7,opt,name=stream" json:"stream,omitempty"`
	State        *State     `protobuf:"bytes,8,opt,name=state" json:"state,omitempty"`
}

func (m *Camera) Reset()                    { *m = Camera{} }
func (m *Camera) String() string            { return proto1.CompactTextString(m) }
func (*Camera) ProtoMessage()               {}
func (*Camera) Descriptor() ([]byte, []int) { return fileDescriptorCameraCloud, []int{6} }

func (m *Camera) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *Camera) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *Camera) GetOwnerId() uint32 {
	if m != nil {
		return m.OwnerId
	}
	return 0
}

func (m *Camera) GetRegisteredAt() *time.Time {
	if m != nil {
		return m.RegisteredAt
	}
	return nil
}

func (m *Camera) GetIsConnected() bool {
	if m != nil {
		return m.IsConnected
	}
	return false
}

func (m *Camera) GetIsOnAir() bool {
	if m != nil {
		return m.IsOnAir
	}
	return false
}

func (m *Camera) GetStream() *Stream {
	if m != nil {
		return m.Stream
	}
	return nil
}

func (m *Camera) GetState() *State {
	if m != nil {
		return m.State
	}
	return nil
}

type CreateCameraStreamRequest struct {
	CameraId      string        `protobuf:"bytes,1,opt,name=camera_id,json=cameraId,proto3" json:"camera_id,omitempty"`
	StereoMode    StereoMode    `protobuf:"varint,2,opt,name=stereo_mode,json=stereoMode,proto3,enum=proto.StereoMode" json:"stereo_mode,omitempty"`
	Projection    Projection    `protobuf:"varint,3,opt,name=projection,proto3,enum=proto.Projection" json:"projection,omitempty"`
	Framerate     uint32        `protobuf:"varint,4,opt,name=framerate,proto3" json:"framerate,omitempty"`
	Bitrate       uint32        `protobuf:"varint,5,opt,name=bitrate,proto3" json:"bitrate,omitempty"`
	Resolution    string        `protobuf:"bytes,6,opt,name=resolution,proto3" json:"resolution,omitempty"`
	IngestionType IngestionType `protobuf:"varint,7,opt,name=ingestion_type,json=ingestionType,proto3,enum=proto.IngestionType" json:"ingestion_type,omitempty"`
}

func (m *CreateCameraStreamRequest) Reset()         { *m = CreateCameraStreamRequest{} }
func (m *CreateCameraStreamRequest) String() string { return proto1.CompactTextString(m) }
func (*CreateCameraStreamRequest) ProtoMessage()    {}
func (*CreateCameraStreamRequest) Descriptor() ([]byte, []int) {
	return fileDescriptorCameraCloud, []int{7}
}

func (m *CreateCameraStreamRequest) GetCameraId() string {
	if m != nil {
		return m.CameraId
	}
	return ""
}

func (m *CreateCameraStreamRequest) GetStereoMode() StereoMode {
	if m != nil {
		return m.StereoMode
	}
	return StereoMode_MONO
}

func (m *CreateCameraStreamRequest) GetProjection() Projection {
	if m != nil {
		return m.Projection
	}
	return Projection_EQUIRECTANGULAR
}

func (m *CreateCameraStreamRequest) GetFramerate() uint32 {
	if m != nil {
		return m.Framerate
	}
	return 0
}

func (m *CreateCameraStreamRequest) GetBitrate() uint32 {
	if m != nil {
		return m.Bitrate
	}
	return 0
}

func (m *CreateCameraStreamRequest) GetResolution() string {
	if m != nil {
		return m.Resolution
	}
	return ""
}

func (m *CreateCameraStreamRequest) GetIngestionType() IngestionType {
	if m != nil {
		return m.IngestionType
	}
	return IngestionType_RTMP
}

type GetCameraStreamsListRequest struct {
	CameraId   string `protobuf:"bytes,1,opt,name=camera_id,json=cameraId,proto3" json:"camera_id,omitempty"`
	OnlyActive bool   `protobuf:"varint,2,opt,name=only_active,json=onlyActive,proto3" json:"only_active,omitempty"`
}

func (m *GetCameraStreamsListRequest) Reset()         { *m = GetCameraStreamsListRequest{} }
func (m *GetCameraStreamsListRequest) String() string { return proto1.CompactTextString(m) }
func (*GetCameraStreamsListRequest) ProtoMessage()    {}
func (*GetCameraStreamsListRequest) Descriptor() ([]byte, []int) {
	return fileDescriptorCameraCloud, []int{8}
}

func (m *GetCameraStreamsListRequest) GetCameraId() string {
	if m != nil {
		return m.CameraId
	}
	return ""
}

func (m *GetCameraStreamsListRequest) GetOnlyActive() bool {
	if m != nil {
		return m.OnlyActive
	}
	return false
}

type CompleteCameraStreamRequest struct {
	CameraId string `protobuf:"bytes,1,opt,name=camera_id,json=cameraId,proto3" json:"camera_id,omitempty"`
	StreamId uint32 `protobuf:"varint,2,opt,name=stream_id,json=streamId,proto3" json:"stream_id,omitempty"`
}

func (m *CompleteCameraStreamRequest) Reset()         { *m = CompleteCameraStreamRequest{} }
func (m *CompleteCameraStreamRequest) String() string { return proto1.CompactTextString(m) }
func (*CompleteCameraStreamRequest) ProtoMessage()    {}
func (*CompleteCameraStreamRequest) Descriptor() ([]byte, []int) {
	return fileDescriptorCameraCloud, []int{9}
}

func (m *CompleteCameraStreamRequest) GetCameraId() string {
	if m != nil {
		return m.CameraId
	}
	return ""
}

func (m *CompleteCameraStreamRequest) GetStreamId() uint32 {
	if m != nil {
		return m.StreamId
	}
	return 0
}

type Stream struct {
	Id                     uint32        `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty" gorm:"primary_key,AUTO_INCREMENT"`
	CameraId               string        `protobuf:"bytes,2,opt,name=camera_id,json=cameraId,proto3" json:"camera_id,omitempty" gorm:"index"`
	OwnerId                uint32        `protobuf:"varint,3,opt,name=owner_id,json=ownerId,proto3" json:"owner_id,omitempty" gorm:"index"`
	StartedAt              *time.Time    `protobuf:"bytes,4,opt,name=started_at,json=startedAt,stdtime" json:"started_at,omitempty"`
	FinishedAt             *time.Time    `protobuf:"bytes,5,opt,name=finished_at,json=finishedAt,stdtime" json:"finished_at,omitempty"`
	StereoMode             StereoMode    `protobuf:"varint,6,opt,name=stereo_mode,json=stereoMode,proto3,enum=proto.StereoMode" json:"stereo_mode,omitempty"`
	Projection             Projection    `protobuf:"varint,7,opt,name=projection,proto3,enum=proto.Projection" json:"projection,omitempty"`
	Framerate              uint32        `protobuf:"varint,8,opt,name=framerate,proto3" json:"framerate,omitempty"`
	Bitrate                uint32        `protobuf:"varint,9,opt,name=bitrate,proto3" json:"bitrate,omitempty"`
	Resolution             string        `protobuf:"bytes,10,opt,name=resolution,proto3" json:"resolution,omitempty"`
	Status                 Stream_Status `protobuf:"varint,11,opt,name=status,proto3,enum=proto.Stream_Status" json:"status,omitempty"`
	IngestionType          IngestionType `protobuf:"varint,12,opt,name=ingestion_type,json=ingestionType,proto3,enum=proto.IngestionType" json:"ingestion_type,omitempty"`
	IngestionStreamName    string        `protobuf:"bytes,13,opt,name=ingestion_stream_name,json=ingestionStreamName,proto3" json:"ingestion_stream_name,omitempty"`
	IngestionAddress       string        `protobuf:"bytes,14,opt,name=ingestion_address,json=ingestionAddress,proto3" json:"ingestion_address,omitempty"`
	IngestionBackupAddress string        `protobuf:"bytes,15,opt,name=ingestion_backup_address,json=ingestionBackupAddress,proto3" json:"ingestion_backup_address,omitempty"`
	PreviewImageUrl        string        `protobuf:"bytes,16,opt,name=preview_image_url,json=previewImageUrl,proto3" json:"preview_image_url,omitempty"`
	PreviewVideoUrl        string        `protobuf:"bytes,18,opt,name=preview_video_url,json=previewVideoUrl,proto3" json:"preview_video_url,omitempty"`
	IsActive               bool          `protobuf:"varint,17,opt,name=is_active,json=isActive,proto3" json:"is_active,omitempty"`
}

func (m *Stream) Reset()                    { *m = Stream{} }
func (m *Stream) String() string            { return proto1.CompactTextString(m) }
func (*Stream) ProtoMessage()               {}
func (*Stream) Descriptor() ([]byte, []int) { return fileDescriptorCameraCloud, []int{10} }

func (m *Stream) GetId() uint32 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *Stream) GetCameraId() string {
	if m != nil {
		return m.CameraId
	}
	return ""
}

func (m *Stream) GetOwnerId() uint32 {
	if m != nil {
		return m.OwnerId
	}
	return 0
}

func (m *Stream) GetStartedAt() *time.Time {
	if m != nil {
		return m.StartedAt
	}
	return nil
}

func (m *Stream) GetFinishedAt() *time.Time {
	if m != nil {
		return m.FinishedAt
	}
	return nil
}

func (m *Stream) GetStereoMode() StereoMode {
	if m != nil {
		return m.StereoMode
	}
	return StereoMode_MONO
}

func (m *Stream) GetProjection() Projection {
	if m != nil {
		return m.Projection
	}
	return Projection_EQUIRECTANGULAR
}

func (m *Stream) GetFramerate() uint32 {
	if m != nil {
		return m.Framerate
	}
	return 0
}

func (m *Stream) GetBitrate() uint32 {
	if m != nil {
		return m.Bitrate
	}
	return 0
}

func (m *Stream) GetResolution() string {
	if m != nil {
		return m.Resolution
	}
	return ""
}

func (m *Stream) GetStatus() Stream_Status {
	if m != nil {
		return m.Status
	}
	return Stream_OFF_AIR
}

func (m *Stream) GetIngestionType() IngestionType {
	if m != nil {
		return m.IngestionType
	}
	return IngestionType_RTMP
}

func (m *Stream) GetIngestionStreamName() string {
	if m != nil {
		return m.IngestionStreamName
	}
	return ""
}

func (m *Stream) GetIngestionAddress() string {
	if m != nil {
		return m.IngestionAddress
	}
	return ""
}

func (m *Stream) GetIngestionBackupAddress() string {
	if m != nil {
		return m.IngestionBackupAddress
	}
	return ""
}

func (m *Stream) GetPreviewImageUrl() string {
	if m != nil {
		return m.PreviewImageUrl
	}
	return ""
}

func (m *Stream) GetPreviewVideoUrl() string {
	if m != nil {
		return m.PreviewVideoUrl
	}
	return ""
}

func (m *Stream) GetIsActive() bool {
	if m != nil {
		return m.IsActive
	}
	return false
}

type Streams struct {
	Items []*Stream `protobuf:"bytes,1,rep,name=items" json:"items,omitempty"`
}

func (m *Streams) Reset()                    { *m = Streams{} }
func (m *Streams) String() string            { return proto1.CompactTextString(m) }
func (*Streams) ProtoMessage()               {}
func (*Streams) Descriptor() ([]byte, []int) { return fileDescriptorCameraCloud, []int{11} }

func (m *Streams) GetItems() []*Stream {
	if m != nil {
		return m.Items
	}
	return nil
}

type UpdateStateCameraRequest struct {
	CameraId string `protobuf:"bytes,1,opt,name=camera_id,json=cameraId,proto3" json:"camera_id,omitempty"`
	State    *State `protobuf:"bytes,2,opt,name=state" json:"state,omitempty"`
}

func (m *UpdateStateCameraRequest) Reset()         { *m = UpdateStateCameraRequest{} }
func (m *UpdateStateCameraRequest) String() string { return proto1.CompactTextString(m) }
func (*UpdateStateCameraRequest) ProtoMessage()    {}
func (*UpdateStateCameraRequest) Descriptor() ([]byte, []int) {
	return fileDescriptorCameraCloud, []int{12}
}

func (m *UpdateStateCameraRequest) GetCameraId() string {
	if m != nil {
		return m.CameraId
	}
	return ""
}

func (m *UpdateStateCameraRequest) GetState() *State {
	if m != nil {
		return m.State
	}
	return nil
}

func init() {
	proto1.RegisterType((*RegisterCameraRequest)(nil), "proto.RegisterCameraRequest")
	proto1.RegisterType((*GetCameraRequest)(nil), "proto.GetCameraRequest")
	proto1.RegisterType((*DeleteCameraRequest)(nil), "proto.DeleteCameraRequest")
	proto1.RegisterType((*UpdateCameraRequest)(nil), "proto.UpdateCameraRequest")
	proto1.RegisterType((*GetCamerasListResponse)(nil), "proto.GetCamerasListResponse")
	proto1.RegisterType((*CameraItemResponse)(nil), "proto.CameraItemResponse")
	proto1.RegisterType((*Camera)(nil), "proto.Camera")
	proto1.RegisterType((*CreateCameraStreamRequest)(nil), "proto.CreateCameraStreamRequest")
	proto1.RegisterType((*GetCameraStreamsListRequest)(nil), "proto.GetCameraStreamsListRequest")
	proto1.RegisterType((*CompleteCameraStreamRequest)(nil), "proto.CompleteCameraStreamRequest")
	proto1.RegisterType((*Stream)(nil), "proto.Stream")
	proto1.RegisterType((*Streams)(nil), "proto.Streams")
	proto1.RegisterType((*UpdateStateCameraRequest)(nil), "proto.UpdateStateCameraRequest")
	proto1.RegisterEnum("proto.Projection", Projection_name, Projection_value)
	proto1.RegisterEnum("proto.StereoMode", StereoMode_name, StereoMode_value)
	proto1.RegisterEnum("proto.IngestionType", IngestionType_name, IngestionType_value)
	proto1.RegisterEnum("proto.Stream_Status", Stream_Status_name, Stream_Status_value)
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// Client API for CameraCloudService service

type CameraCloudServiceClient interface {
	RegisterCamera(ctx context.Context, in *RegisterCameraRequest, opts ...grpc.CallOption) (*Camera, error)
	GetCamera(ctx context.Context, in *GetCameraRequest, opts ...grpc.CallOption) (*Camera, error)
	DeleteCamera(ctx context.Context, in *DeleteCameraRequest, opts ...grpc.CallOption) (*google_protobuf2.Empty, error)
	UpdateCamera(ctx context.Context, in *UpdateCameraRequest, opts ...grpc.CallOption) (*Camera, error)
	GetCamerasList(ctx context.Context, in *google_protobuf2.Empty, opts ...grpc.CallOption) (*GetCamerasListResponse, error)
	CreateStream(ctx context.Context, in *CreateCameraStreamRequest, opts ...grpc.CallOption) (*Stream, error)
	GetCameraStreamsList(ctx context.Context, in *GetCameraStreamsListRequest, opts ...grpc.CallOption) (*Streams, error)
	CompleteStream(ctx context.Context, in *CompleteCameraStreamRequest, opts ...grpc.CallOption) (*google_protobuf2.Empty, error)
	RemoteControl(ctx context.Context, opts ...grpc.CallOption) (CameraCloudService_RemoteControlClient, error)
}

type cameraCloudServiceClient struct {
	cc *grpc.ClientConn
}

func NewCameraCloudServiceClient(cc *grpc.ClientConn) CameraCloudServiceClient {
	return &cameraCloudServiceClient{cc}
}

func (c *cameraCloudServiceClient) RegisterCamera(ctx context.Context, in *RegisterCameraRequest, opts ...grpc.CallOption) (*Camera, error) {
	out := new(Camera)
	err := grpc.Invoke(ctx, "/proto.CameraCloudService/RegisterCamera", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cameraCloudServiceClient) GetCamera(ctx context.Context, in *GetCameraRequest, opts ...grpc.CallOption) (*Camera, error) {
	out := new(Camera)
	err := grpc.Invoke(ctx, "/proto.CameraCloudService/GetCamera", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cameraCloudServiceClient) DeleteCamera(ctx context.Context, in *DeleteCameraRequest, opts ...grpc.CallOption) (*google_protobuf2.Empty, error) {
	out := new(google_protobuf2.Empty)
	err := grpc.Invoke(ctx, "/proto.CameraCloudService/DeleteCamera", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cameraCloudServiceClient) UpdateCamera(ctx context.Context, in *UpdateCameraRequest, opts ...grpc.CallOption) (*Camera, error) {
	out := new(Camera)
	err := grpc.Invoke(ctx, "/proto.CameraCloudService/UpdateCamera", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cameraCloudServiceClient) GetCamerasList(ctx context.Context, in *google_protobuf2.Empty, opts ...grpc.CallOption) (*GetCamerasListResponse, error) {
	out := new(GetCamerasListResponse)
	err := grpc.Invoke(ctx, "/proto.CameraCloudService/GetCamerasList", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cameraCloudServiceClient) CreateStream(ctx context.Context, in *CreateCameraStreamRequest, opts ...grpc.CallOption) (*Stream, error) {
	out := new(Stream)
	err := grpc.Invoke(ctx, "/proto.CameraCloudService/CreateStream", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cameraCloudServiceClient) GetCameraStreamsList(ctx context.Context, in *GetCameraStreamsListRequest, opts ...grpc.CallOption) (*Streams, error) {
	out := new(Streams)
	err := grpc.Invoke(ctx, "/proto.CameraCloudService/GetCameraStreamsList", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cameraCloudServiceClient) CompleteStream(ctx context.Context, in *CompleteCameraStreamRequest, opts ...grpc.CallOption) (*google_protobuf2.Empty, error) {
	out := new(google_protobuf2.Empty)
	err := grpc.Invoke(ctx, "/proto.CameraCloudService/CompleteStream", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cameraCloudServiceClient) RemoteControl(ctx context.Context, opts ...grpc.CallOption) (CameraCloudService_RemoteControlClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_CameraCloudService_serviceDesc.Streams[0], c.cc, "/proto.CameraCloudService/RemoteControl", opts...)
	if err != nil {
		return nil, err
	}
	x := &cameraCloudServiceRemoteControlClient{stream}
	return x, nil
}

type CameraCloudService_RemoteControlClient interface {
	Send(*UpdateStateCameraRequest) error
	Recv() (*State, error)
	grpc.ClientStream
}

type cameraCloudServiceRemoteControlClient struct {
	grpc.ClientStream
}

func (x *cameraCloudServiceRemoteControlClient) Send(m *UpdateStateCameraRequest) error {
	return x.ClientStream.SendMsg(m)
}

func (x *cameraCloudServiceRemoteControlClient) Recv() (*State, error) {
	m := new(State)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// Server API for CameraCloudService service

type CameraCloudServiceServer interface {
	RegisterCamera(context.Context, *RegisterCameraRequest) (*Camera, error)
	GetCamera(context.Context, *GetCameraRequest) (*Camera, error)
	DeleteCamera(context.Context, *DeleteCameraRequest) (*google_protobuf2.Empty, error)
	UpdateCamera(context.Context, *UpdateCameraRequest) (*Camera, error)
	GetCamerasList(context.Context, *google_protobuf2.Empty) (*GetCamerasListResponse, error)
	CreateStream(context.Context, *CreateCameraStreamRequest) (*Stream, error)
	GetCameraStreamsList(context.Context, *GetCameraStreamsListRequest) (*Streams, error)
	CompleteStream(context.Context, *CompleteCameraStreamRequest) (*google_protobuf2.Empty, error)
	RemoteControl(CameraCloudService_RemoteControlServer) error
}

func RegisterCameraCloudServiceServer(s *grpc.Server, srv CameraCloudServiceServer) {
	s.RegisterService(&_CameraCloudService_serviceDesc, srv)
}

func _CameraCloudService_RegisterCamera_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RegisterCameraRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CameraCloudServiceServer).RegisterCamera(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.CameraCloudService/RegisterCamera",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CameraCloudServiceServer).RegisterCamera(ctx, req.(*RegisterCameraRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CameraCloudService_GetCamera_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetCameraRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CameraCloudServiceServer).GetCamera(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.CameraCloudService/GetCamera",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CameraCloudServiceServer).GetCamera(ctx, req.(*GetCameraRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CameraCloudService_DeleteCamera_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteCameraRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CameraCloudServiceServer).DeleteCamera(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.CameraCloudService/DeleteCamera",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CameraCloudServiceServer).DeleteCamera(ctx, req.(*DeleteCameraRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CameraCloudService_UpdateCamera_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateCameraRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CameraCloudServiceServer).UpdateCamera(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.CameraCloudService/UpdateCamera",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CameraCloudServiceServer).UpdateCamera(ctx, req.(*UpdateCameraRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CameraCloudService_GetCamerasList_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(google_protobuf2.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CameraCloudServiceServer).GetCamerasList(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.CameraCloudService/GetCamerasList",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CameraCloudServiceServer).GetCamerasList(ctx, req.(*google_protobuf2.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _CameraCloudService_CreateStream_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateCameraStreamRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CameraCloudServiceServer).CreateStream(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.CameraCloudService/CreateStream",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CameraCloudServiceServer).CreateStream(ctx, req.(*CreateCameraStreamRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CameraCloudService_GetCameraStreamsList_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetCameraStreamsListRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CameraCloudServiceServer).GetCameraStreamsList(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.CameraCloudService/GetCameraStreamsList",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CameraCloudServiceServer).GetCameraStreamsList(ctx, req.(*GetCameraStreamsListRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CameraCloudService_CompleteStream_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CompleteCameraStreamRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CameraCloudServiceServer).CompleteStream(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.CameraCloudService/CompleteStream",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CameraCloudServiceServer).CompleteStream(ctx, req.(*CompleteCameraStreamRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CameraCloudService_RemoteControl_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(CameraCloudServiceServer).RemoteControl(&cameraCloudServiceRemoteControlServer{stream})
}

type CameraCloudService_RemoteControlServer interface {
	Send(*State) error
	Recv() (*UpdateStateCameraRequest, error)
	grpc.ServerStream
}

type cameraCloudServiceRemoteControlServer struct {
	grpc.ServerStream
}

func (x *cameraCloudServiceRemoteControlServer) Send(m *State) error {
	return x.ServerStream.SendMsg(m)
}

func (x *cameraCloudServiceRemoteControlServer) Recv() (*UpdateStateCameraRequest, error) {
	m := new(UpdateStateCameraRequest)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

var _CameraCloudService_serviceDesc = grpc.ServiceDesc{
	ServiceName: "proto.CameraCloudService",
	HandlerType: (*CameraCloudServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "RegisterCamera",
			Handler:    _CameraCloudService_RegisterCamera_Handler,
		},
		{
			MethodName: "GetCamera",
			Handler:    _CameraCloudService_GetCamera_Handler,
		},
		{
			MethodName: "DeleteCamera",
			Handler:    _CameraCloudService_DeleteCamera_Handler,
		},
		{
			MethodName: "UpdateCamera",
			Handler:    _CameraCloudService_UpdateCamera_Handler,
		},
		{
			MethodName: "GetCamerasList",
			Handler:    _CameraCloudService_GetCamerasList_Handler,
		},
		{
			MethodName: "CreateStream",
			Handler:    _CameraCloudService_CreateStream_Handler,
		},
		{
			MethodName: "GetCameraStreamsList",
			Handler:    _CameraCloudService_GetCameraStreamsList_Handler,
		},
		{
			MethodName: "CompleteStream",
			Handler:    _CameraCloudService_CompleteStream_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "RemoteControl",
			Handler:       _CameraCloudService_RemoteControl_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
	},
	Metadata: "camera_cloud.proto",
}

func (m *RegisterCameraRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RegisterCameraRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Id) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintCameraCloud(dAtA, i, uint64(len(m.Id)))
		i += copy(dAtA[i:], m.Id)
	}
	if len(m.Name) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintCameraCloud(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	return i, nil
}

func (m *GetCameraRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetCameraRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Id) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintCameraCloud(dAtA, i, uint64(len(m.Id)))
		i += copy(dAtA[i:], m.Id)
	}
	return i, nil
}

func (m *DeleteCameraRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DeleteCameraRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Id) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintCameraCloud(dAtA, i, uint64(len(m.Id)))
		i += copy(dAtA[i:], m.Id)
	}
	return i, nil
}

func (m *UpdateCameraRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UpdateCameraRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Id) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintCameraCloud(dAtA, i, uint64(len(m.Id)))
		i += copy(dAtA[i:], m.Id)
	}
	if len(m.Name) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintCameraCloud(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	return i, nil
}

func (m *GetCamerasListResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetCamerasListResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Items) > 0 {
		for _, msg := range m.Items {
			dAtA[i] = 0xa
			i++
			i = encodeVarintCameraCloud(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *CameraItemResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CameraItemResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Id) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintCameraCloud(dAtA, i, uint64(len(m.Id)))
		i += copy(dAtA[i:], m.Id)
	}
	if len(m.Name) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintCameraCloud(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if m.RegisteredAt != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintCameraCloud(dAtA, i, uint64(types.SizeOfStdTime(*m.RegisteredAt)))
		n1, err := types.StdTimeMarshalTo(*m.RegisteredAt, dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n1
	}
	if m.IsConnected {
		dAtA[i] = 0x28
		i++
		if m.IsConnected {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.IsOnAir {
		dAtA[i] = 0x30
		i++
		if m.IsOnAir {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if len(m.PreviewImageUrl) > 0 {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintCameraCloud(dAtA, i, uint64(len(m.PreviewImageUrl)))
		i += copy(dAtA[i:], m.PreviewImageUrl)
	}
	if m.OutputType != 0 {
		dAtA[i] = 0x40
		i++
		i = encodeVarintCameraCloud(dAtA, i, uint64(m.OutputType))
	}
	return i, nil
}

func (m *Camera) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Camera) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Id) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintCameraCloud(dAtA, i, uint64(len(m.Id)))
		i += copy(dAtA[i:], m.Id)
	}
	if len(m.Name) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintCameraCloud(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if m.OwnerId != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintCameraCloud(dAtA, i, uint64(m.OwnerId))
	}
	if m.RegisteredAt != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintCameraCloud(dAtA, i, uint64(types.SizeOfStdTime(*m.RegisteredAt)))
		n2, err := types.StdTimeMarshalTo(*m.RegisteredAt, dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n2
	}
	if m.IsConnected {
		dAtA[i] = 0x28
		i++
		if m.IsConnected {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.IsOnAir {
		dAtA[i] = 0x30
		i++
		if m.IsOnAir {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.Stream != nil {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintCameraCloud(dAtA, i, uint64(m.Stream.Size()))
		n3, err := m.Stream.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n3
	}
	if m.State != nil {
		dAtA[i] = 0x42
		i++
		i = encodeVarintCameraCloud(dAtA, i, uint64(m.State.Size()))
		n4, err := m.State.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n4
	}
	return i, nil
}

func (m *CreateCameraStreamRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CreateCameraStreamRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.CameraId) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintCameraCloud(dAtA, i, uint64(len(m.CameraId)))
		i += copy(dAtA[i:], m.CameraId)
	}
	if m.StereoMode != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintCameraCloud(dAtA, i, uint64(m.StereoMode))
	}
	if m.Projection != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintCameraCloud(dAtA, i, uint64(m.Projection))
	}
	if m.Framerate != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintCameraCloud(dAtA, i, uint64(m.Framerate))
	}
	if m.Bitrate != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintCameraCloud(dAtA, i, uint64(m.Bitrate))
	}
	if len(m.Resolution) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintCameraCloud(dAtA, i, uint64(len(m.Resolution)))
		i += copy(dAtA[i:], m.Resolution)
	}
	if m.IngestionType != 0 {
		dAtA[i] = 0x38
		i++
		i = encodeVarintCameraCloud(dAtA, i, uint64(m.IngestionType))
	}
	return i, nil
}

func (m *GetCameraStreamsListRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetCameraStreamsListRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.CameraId) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintCameraCloud(dAtA, i, uint64(len(m.CameraId)))
		i += copy(dAtA[i:], m.CameraId)
	}
	if m.OnlyActive {
		dAtA[i] = 0x10
		i++
		if m.OnlyActive {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *CompleteCameraStreamRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CompleteCameraStreamRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.CameraId) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintCameraCloud(dAtA, i, uint64(len(m.CameraId)))
		i += copy(dAtA[i:], m.CameraId)
	}
	if m.StreamId != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintCameraCloud(dAtA, i, uint64(m.StreamId))
	}
	return i, nil
}

func (m *Stream) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Stream) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Id != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintCameraCloud(dAtA, i, uint64(m.Id))
	}
	if len(m.CameraId) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintCameraCloud(dAtA, i, uint64(len(m.CameraId)))
		i += copy(dAtA[i:], m.CameraId)
	}
	if m.OwnerId != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintCameraCloud(dAtA, i, uint64(m.OwnerId))
	}
	if m.StartedAt != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintCameraCloud(dAtA, i, uint64(types.SizeOfStdTime(*m.StartedAt)))
		n5, err := types.StdTimeMarshalTo(*m.StartedAt, dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n5
	}
	if m.FinishedAt != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintCameraCloud(dAtA, i, uint64(types.SizeOfStdTime(*m.FinishedAt)))
		n6, err := types.StdTimeMarshalTo(*m.FinishedAt, dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n6
	}
	if m.StereoMode != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintCameraCloud(dAtA, i, uint64(m.StereoMode))
	}
	if m.Projection != 0 {
		dAtA[i] = 0x38
		i++
		i = encodeVarintCameraCloud(dAtA, i, uint64(m.Projection))
	}
	if m.Framerate != 0 {
		dAtA[i] = 0x40
		i++
		i = encodeVarintCameraCloud(dAtA, i, uint64(m.Framerate))
	}
	if m.Bitrate != 0 {
		dAtA[i] = 0x48
		i++
		i = encodeVarintCameraCloud(dAtA, i, uint64(m.Bitrate))
	}
	if len(m.Resolution) > 0 {
		dAtA[i] = 0x52
		i++
		i = encodeVarintCameraCloud(dAtA, i, uint64(len(m.Resolution)))
		i += copy(dAtA[i:], m.Resolution)
	}
	if m.Status != 0 {
		dAtA[i] = 0x58
		i++
		i = encodeVarintCameraCloud(dAtA, i, uint64(m.Status))
	}
	if m.IngestionType != 0 {
		dAtA[i] = 0x60
		i++
		i = encodeVarintCameraCloud(dAtA, i, uint64(m.IngestionType))
	}
	if len(m.IngestionStreamName) > 0 {
		dAtA[i] = 0x6a
		i++
		i = encodeVarintCameraCloud(dAtA, i, uint64(len(m.IngestionStreamName)))
		i += copy(dAtA[i:], m.IngestionStreamName)
	}
	if len(m.IngestionAddress) > 0 {
		dAtA[i] = 0x72
		i++
		i = encodeVarintCameraCloud(dAtA, i, uint64(len(m.IngestionAddress)))
		i += copy(dAtA[i:], m.IngestionAddress)
	}
	if len(m.IngestionBackupAddress) > 0 {
		dAtA[i] = 0x7a
		i++
		i = encodeVarintCameraCloud(dAtA, i, uint64(len(m.IngestionBackupAddress)))
		i += copy(dAtA[i:], m.IngestionBackupAddress)
	}
	if len(m.PreviewImageUrl) > 0 {
		dAtA[i] = 0x82
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintCameraCloud(dAtA, i, uint64(len(m.PreviewImageUrl)))
		i += copy(dAtA[i:], m.PreviewImageUrl)
	}
	if m.IsActive {
		dAtA[i] = 0x88
		i++
		dAtA[i] = 0x1
		i++
		if m.IsActive {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if len(m.PreviewVideoUrl) > 0 {
		dAtA[i] = 0x92
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintCameraCloud(dAtA, i, uint64(len(m.PreviewVideoUrl)))
		i += copy(dAtA[i:], m.PreviewVideoUrl)
	}
	return i, nil
}

func (m *Streams) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Streams) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Items) > 0 {
		for _, msg := range m.Items {
			dAtA[i] = 0xa
			i++
			i = encodeVarintCameraCloud(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *UpdateStateCameraRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UpdateStateCameraRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.CameraId) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintCameraCloud(dAtA, i, uint64(len(m.CameraId)))
		i += copy(dAtA[i:], m.CameraId)
	}
	if m.State != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintCameraCloud(dAtA, i, uint64(m.State.Size()))
		n7, err := m.State.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n7
	}
	return i, nil
}

func encodeVarintCameraCloud(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *RegisterCameraRequest) Size() (n int) {
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovCameraCloud(uint64(l))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovCameraCloud(uint64(l))
	}
	return n
}

func (m *GetCameraRequest) Size() (n int) {
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovCameraCloud(uint64(l))
	}
	return n
}

func (m *DeleteCameraRequest) Size() (n int) {
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovCameraCloud(uint64(l))
	}
	return n
}

func (m *UpdateCameraRequest) Size() (n int) {
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovCameraCloud(uint64(l))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovCameraCloud(uint64(l))
	}
	return n
}

func (m *GetCamerasListResponse) Size() (n int) {
	var l int
	_ = l
	if len(m.Items) > 0 {
		for _, e := range m.Items {
			l = e.Size()
			n += 1 + l + sovCameraCloud(uint64(l))
		}
	}
	return n
}

func (m *CameraItemResponse) Size() (n int) {
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovCameraCloud(uint64(l))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovCameraCloud(uint64(l))
	}
	if m.RegisteredAt != nil {
		l = types.SizeOfStdTime(*m.RegisteredAt)
		n += 1 + l + sovCameraCloud(uint64(l))
	}
	if m.IsConnected {
		n += 2
	}
	if m.IsOnAir {
		n += 2
	}
	l = len(m.PreviewImageUrl)
	if l > 0 {
		n += 1 + l + sovCameraCloud(uint64(l))
	}
	if m.OutputType != 0 {
		n += 1 + sovCameraCloud(uint64(m.OutputType))
	}
	return n
}

func (m *Camera) Size() (n int) {
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovCameraCloud(uint64(l))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovCameraCloud(uint64(l))
	}
	if m.OwnerId != 0 {
		n += 1 + sovCameraCloud(uint64(m.OwnerId))
	}
	if m.RegisteredAt != nil {
		l = types.SizeOfStdTime(*m.RegisteredAt)
		n += 1 + l + sovCameraCloud(uint64(l))
	}
	if m.IsConnected {
		n += 2
	}
	if m.IsOnAir {
		n += 2
	}
	if m.Stream != nil {
		l = m.Stream.Size()
		n += 1 + l + sovCameraCloud(uint64(l))
	}
	if m.State != nil {
		l = m.State.Size()
		n += 1 + l + sovCameraCloud(uint64(l))
	}
	return n
}

func (m *CreateCameraStreamRequest) Size() (n int) {
	var l int
	_ = l
	l = len(m.CameraId)
	if l > 0 {
		n += 1 + l + sovCameraCloud(uint64(l))
	}
	if m.StereoMode != 0 {
		n += 1 + sovCameraCloud(uint64(m.StereoMode))
	}
	if m.Projection != 0 {
		n += 1 + sovCameraCloud(uint64(m.Projection))
	}
	if m.Framerate != 0 {
		n += 1 + sovCameraCloud(uint64(m.Framerate))
	}
	if m.Bitrate != 0 {
		n += 1 + sovCameraCloud(uint64(m.Bitrate))
	}
	l = len(m.Resolution)
	if l > 0 {
		n += 1 + l + sovCameraCloud(uint64(l))
	}
	if m.IngestionType != 0 {
		n += 1 + sovCameraCloud(uint64(m.IngestionType))
	}
	return n
}

func (m *GetCameraStreamsListRequest) Size() (n int) {
	var l int
	_ = l
	l = len(m.CameraId)
	if l > 0 {
		n += 1 + l + sovCameraCloud(uint64(l))
	}
	if m.OnlyActive {
		n += 2
	}
	return n
}

func (m *CompleteCameraStreamRequest) Size() (n int) {
	var l int
	_ = l
	l = len(m.CameraId)
	if l > 0 {
		n += 1 + l + sovCameraCloud(uint64(l))
	}
	if m.StreamId != 0 {
		n += 1 + sovCameraCloud(uint64(m.StreamId))
	}
	return n
}

func (m *Stream) Size() (n int) {
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovCameraCloud(uint64(m.Id))
	}
	l = len(m.CameraId)
	if l > 0 {
		n += 1 + l + sovCameraCloud(uint64(l))
	}
	if m.OwnerId != 0 {
		n += 1 + sovCameraCloud(uint64(m.OwnerId))
	}
	if m.StartedAt != nil {
		l = types.SizeOfStdTime(*m.StartedAt)
		n += 1 + l + sovCameraCloud(uint64(l))
	}
	if m.FinishedAt != nil {
		l = types.SizeOfStdTime(*m.FinishedAt)
		n += 1 + l + sovCameraCloud(uint64(l))
	}
	if m.StereoMode != 0 {
		n += 1 + sovCameraCloud(uint64(m.StereoMode))
	}
	if m.Projection != 0 {
		n += 1 + sovCameraCloud(uint64(m.Projection))
	}
	if m.Framerate != 0 {
		n += 1 + sovCameraCloud(uint64(m.Framerate))
	}
	if m.Bitrate != 0 {
		n += 1 + sovCameraCloud(uint64(m.Bitrate))
	}
	l = len(m.Resolution)
	if l > 0 {
		n += 1 + l + sovCameraCloud(uint64(l))
	}
	if m.Status != 0 {
		n += 1 + sovCameraCloud(uint64(m.Status))
	}
	if m.IngestionType != 0 {
		n += 1 + sovCameraCloud(uint64(m.IngestionType))
	}
	l = len(m.IngestionStreamName)
	if l > 0 {
		n += 1 + l + sovCameraCloud(uint64(l))
	}
	l = len(m.IngestionAddress)
	if l > 0 {
		n += 1 + l + sovCameraCloud(uint64(l))
	}
	l = len(m.IngestionBackupAddress)
	if l > 0 {
		n += 1 + l + sovCameraCloud(uint64(l))
	}
	l = len(m.PreviewImageUrl)
	if l > 0 {
		n += 2 + l + sovCameraCloud(uint64(l))
	}
	if m.IsActive {
		n += 3
	}
	l = len(m.PreviewVideoUrl)
	if l > 0 {
		n += 2 + l + sovCameraCloud(uint64(l))
	}
	return n
}

func (m *Streams) Size() (n int) {
	var l int
	_ = l
	if len(m.Items) > 0 {
		for _, e := range m.Items {
			l = e.Size()
			n += 1 + l + sovCameraCloud(uint64(l))
		}
	}
	return n
}

func (m *UpdateStateCameraRequest) Size() (n int) {
	var l int
	_ = l
	l = len(m.CameraId)
	if l > 0 {
		n += 1 + l + sovCameraCloud(uint64(l))
	}
	if m.State != nil {
		l = m.State.Size()
		n += 1 + l + sovCameraCloud(uint64(l))
	}
	return n
}

func sovCameraCloud(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozCameraCloud(x uint64) (n int) {
	return sovCameraCloud(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *RegisterCameraRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCameraCloud
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RegisterCameraRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RegisterCameraRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCameraCloud
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCameraCloud
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCameraCloud
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCameraCloud
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCameraCloud(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCameraCloud
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetCameraRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCameraCloud
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetCameraRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetCameraRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCameraCloud
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCameraCloud
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCameraCloud(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCameraCloud
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DeleteCameraRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCameraCloud
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DeleteCameraRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DeleteCameraRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCameraCloud
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCameraCloud
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCameraCloud(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCameraCloud
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UpdateCameraRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCameraCloud
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UpdateCameraRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UpdateCameraRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCameraCloud
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCameraCloud
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCameraCloud
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCameraCloud
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCameraCloud(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCameraCloud
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetCamerasListResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCameraCloud
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetCamerasListResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetCamerasListResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Items", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCameraCloud
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCameraCloud
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Items = append(m.Items, &CameraItemResponse{})
			if err := m.Items[len(m.Items)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCameraCloud(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCameraCloud
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CameraItemResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCameraCloud
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CameraItemResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CameraItemResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCameraCloud
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCameraCloud
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCameraCloud
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCameraCloud
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RegisteredAt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCameraCloud
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCameraCloud
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.RegisteredAt == nil {
				m.RegisteredAt = new(time.Time)
			}
			if err := types.StdTimeUnmarshal(m.RegisteredAt, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsConnected", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCameraCloud
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsConnected = bool(v != 0)
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsOnAir", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCameraCloud
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsOnAir = bool(v != 0)
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PreviewImageUrl", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCameraCloud
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCameraCloud
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PreviewImageUrl = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OutputType", wireType)
			}
			m.OutputType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCameraCloud
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OutputType |= (Output_OutputType(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCameraCloud(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCameraCloud
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Camera) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCameraCloud
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Camera: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Camera: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCameraCloud
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCameraCloud
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCameraCloud
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCameraCloud
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OwnerId", wireType)
			}
			m.OwnerId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCameraCloud
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OwnerId |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RegisteredAt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCameraCloud
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCameraCloud
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.RegisteredAt == nil {
				m.RegisteredAt = new(time.Time)
			}
			if err := types.StdTimeUnmarshal(m.RegisteredAt, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsConnected", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCameraCloud
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsConnected = bool(v != 0)
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsOnAir", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCameraCloud
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsOnAir = bool(v != 0)
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Stream", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCameraCloud
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCameraCloud
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Stream == nil {
				m.Stream = &Stream{}
			}
			if err := m.Stream.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field State", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCameraCloud
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCameraCloud
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.State == nil {
				m.State = &State{}
			}
			if err := m.State.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCameraCloud(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCameraCloud
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CreateCameraStreamRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCameraCloud
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CreateCameraStreamRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CreateCameraStreamRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CameraId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCameraCloud
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCameraCloud
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CameraId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StereoMode", wireType)
			}
			m.StereoMode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCameraCloud
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StereoMode |= (StereoMode(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Projection", wireType)
			}
			m.Projection = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCameraCloud
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Projection |= (Projection(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Framerate", wireType)
			}
			m.Framerate = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCameraCloud
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Framerate |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Bitrate", wireType)
			}
			m.Bitrate = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCameraCloud
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Bitrate |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Resolution", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCameraCloud
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCameraCloud
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Resolution = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IngestionType", wireType)
			}
			m.IngestionType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCameraCloud
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IngestionType |= (IngestionType(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCameraCloud(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCameraCloud
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetCameraStreamsListRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCameraCloud
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetCameraStreamsListRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetCameraStreamsListRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CameraId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCameraCloud
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCameraCloud
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CameraId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OnlyActive", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCameraCloud
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.OnlyActive = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipCameraCloud(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCameraCloud
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CompleteCameraStreamRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCameraCloud
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CompleteCameraStreamRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CompleteCameraStreamRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CameraId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCameraCloud
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCameraCloud
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CameraId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StreamId", wireType)
			}
			m.StreamId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCameraCloud
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StreamId |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCameraCloud(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCameraCloud
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Stream) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCameraCloud
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Stream: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Stream: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCameraCloud
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CameraId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCameraCloud
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCameraCloud
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CameraId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OwnerId", wireType)
			}
			m.OwnerId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCameraCloud
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OwnerId |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartedAt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCameraCloud
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCameraCloud
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.StartedAt == nil {
				m.StartedAt = new(time.Time)
			}
			if err := types.StdTimeUnmarshal(m.StartedAt, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FinishedAt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCameraCloud
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCameraCloud
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.FinishedAt == nil {
				m.FinishedAt = new(time.Time)
			}
			if err := types.StdTimeUnmarshal(m.FinishedAt, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StereoMode", wireType)
			}
			m.StereoMode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCameraCloud
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StereoMode |= (StereoMode(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Projection", wireType)
			}
			m.Projection = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCameraCloud
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Projection |= (Projection(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Framerate", wireType)
			}
			m.Framerate = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCameraCloud
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Framerate |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Bitrate", wireType)
			}
			m.Bitrate = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCameraCloud
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Bitrate |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Resolution", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCameraCloud
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCameraCloud
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Resolution = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCameraCloud
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= (Stream_Status(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IngestionType", wireType)
			}
			m.IngestionType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCameraCloud
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IngestionType |= (IngestionType(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IngestionStreamName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCameraCloud
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCameraCloud
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.IngestionStreamName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IngestionAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCameraCloud
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCameraCloud
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.IngestionAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IngestionBackupAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCameraCloud
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCameraCloud
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.IngestionBackupAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 16:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PreviewImageUrl", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCameraCloud
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCameraCloud
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PreviewImageUrl = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 17:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsActive", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCameraCloud
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsActive = bool(v != 0)
		case 18:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PreviewVideoUrl", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCameraCloud
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCameraCloud
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PreviewVideoUrl = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCameraCloud(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCameraCloud
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Streams) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCameraCloud
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Streams: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Streams: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Items", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCameraCloud
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCameraCloud
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Items = append(m.Items, &Stream{})
			if err := m.Items[len(m.Items)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCameraCloud(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCameraCloud
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UpdateStateCameraRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCameraCloud
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UpdateStateCameraRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UpdateStateCameraRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CameraId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCameraCloud
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCameraCloud
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CameraId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field State", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCameraCloud
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCameraCloud
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.State == nil {
				m.State = &State{}
			}
			if err := m.State.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCameraCloud(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCameraCloud
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipCameraCloud(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowCameraCloud
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowCameraCloud
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowCameraCloud
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthCameraCloud
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowCameraCloud
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipCameraCloud(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthCameraCloud = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowCameraCloud   = fmt.Errorf("proto: integer overflow")
)

func init() { proto1.RegisterFile("camera_cloud.proto", fileDescriptorCameraCloud) }

var fileDescriptorCameraCloud = []byte{
	// 1598 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xcc, 0x57, 0x4f, 0x73, 0x23, 0x47,
	0x15, 0xf7, 0x68, 0xd7, 0xfa, 0xf3, 0xf4, 0xc7, 0x72, 0x7b, 0xe3, 0x8c, 0xe5, 0x8d, 0x35, 0x19,
	0xb3, 0x15, 0x95, 0xb2, 0x96, 0xb4, 0x0a, 0x0b, 0x89, 0x29, 0x0a, 0x24, 0x45, 0x9b, 0x08, 0x62,
	0x6b, 0x33, 0x2b, 0x27, 0x90, 0x14, 0x51, 0x46, 0x9a, 0xb6, 0xd2, 0xac, 0x66, 0x5a, 0x4c, 0xb7,
	0x6c, 0xcc, 0x96, 0x0f, 0x70, 0xd8, 0x2a, 0x2e, 0x40, 0x15, 0x17, 0xee, 0x14, 0x1f, 0x81, 0x33,
	0x57, 0x8e, 0x50, 0xdc, 0xd7, 0x94, 0xe1, 0x13, 0xec, 0x27, 0xa0, 0xa6, 0x7b, 0x34, 0xd2, 0x48,
	0xf2, 0x62, 0x53, 0x1c, 0x72, 0xd2, 0x74, 0xbf, 0xbf, 0xfd, 0xde, 0xfb, 0xbd, 0xf7, 0x04, 0xa8,
	0x6f, 0xda, 0xd8, 0x35, 0xbb, 0xfd, 0x21, 0x1d, 0x5b, 0xa5, 0x91, 0x4b, 0x39, 0x45, 0xab, 0xe2,
	0x27, 0x77, 0x77, 0x40, 0xe9, 0x60, 0x88, 0xcb, 0xe6, 0x88, 0x94, 0x4d, 0xc7, 0xa1, 0xdc, 0xe4,
	0x84, 0x3a, 0x4c, 0x32, 0xe5, 0xf2, 0x3e, 0x55, 0x9c, 0x7a, 0xe3, 0xe3, 0x32, 0x27, 0x36, 0x66,
	0xdc, 0xb4, 0x47, 0x3e, 0xc3, 0xf6, 0x3c, 0x03, 0xb6, 0x47, 0xfc, 0xcc, 0x27, 0xee, 0x0d, 0x08,
	0xff, 0x6a, 0xdc, 0x2b, 0xf5, 0xa9, 0x5d, 0x1e, 0xd0, 0x01, 0x9d, 0x72, 0x79, 0x27, 0x71, 0x10,
	0x5f, 0x3e, 0xfb, 0xb7, 0x66, 0xd8, 0xed, 0x53, 0xc2, 0x9f, 0xd2, 0xd3, 0xf2, 0x80, 0xee, 0x09,
	0xe2, 0xde, 0x89, 0x39, 0x24, 0x96, 0xc9, 0xa9, 0xcb, 0xca, 0xc1, 0xa7, 0x2f, 0xb7, 0x3e, 0x79,
	0x1d, 0x75, 0xb1, 0xbc, 0xd2, 0x9f, 0x2b, 0xf0, 0x9a, 0x81, 0x07, 0x84, 0x71, 0xec, 0x36, 0x04,
	0xd5, 0xc0, 0x3f, 0x1b, 0x63, 0xc6, 0xd1, 0x37, 0x21, 0x42, 0x2c, 0x55, 0xd1, 0x94, 0x42, 0xa2,
	0xfe, 0x8d, 0xcb, 0x8b, 0xbc, 0x06, 0xd9, 0x2f, 0x3e, 0x37, 0xf7, 0x8e, 0x6b, 0x7b, 0x8f, 0x2a,
	0x7b, 0xef, 0xfd, 0xe4, 0xd9, 0x83, 0xea, 0x79, 0x31, 0x75, 0xea, 0x52, 0x67, 0xa0, 0x1d, 0x53,
	0xd7, 0x36, 0xb9, 0x11, 0x21, 0x16, 0xfa, 0x36, 0xdc, 0x76, 0x4c, 0x1b, 0xab, 0x11, 0x21, 0xb7,
	0x7b, 0x79, 0x91, 0xcf, 0x17, 0xb7, 0xed, 0x31, 0xe3, 0x9a, 0x43, 0xb9, 0xd6, 0xc3, 0x9a, 0xe9,
	0x68, 0xe2, 0xe5, 0x1a, 0xe3, 0x2e, 0x71, 0x06, 0x3f, 0x52, 0x0c, 0x21, 0xa0, 0xeb, 0x90, 0xfd,
	0x00, 0xf3, 0xb0, 0x0b, 0x99, 0xa9, 0x0b, 0x9e, 0x72, 0xfd, 0x1e, 0x6c, 0xbc, 0x8f, 0x87, 0x98,
	0xe3, 0x57, 0xb3, 0x7d, 0x01, 0x1b, 0x47, 0x23, 0xcb, 0xfc, 0x2f, 0x6c, 0xff, 0xbb, 0xab, 0x2d,
	0xd8, 0x0c, 0x5c, 0x65, 0x1f, 0x11, 0xc6, 0x0d, 0xcc, 0x46, 0xd4, 0x61, 0x18, 0x95, 0x61, 0x95,
	0x70, 0x6c, 0x33, 0x55, 0xd1, 0x6e, 0x15, 0x92, 0xd5, 0x2d, 0x19, 0xe4, 0x92, 0x64, 0x6d, 0x71,
	0x6c, 0x4f, 0x38, 0x0d, 0xc9, 0xa7, 0xff, 0x29, 0x02, 0x68, 0x91, 0xba, 0xe0, 0x2a, 0x9a, 0x75,
	0x55, 0x7a, 0x81, 0x9a, 0x90, 0x76, 0xfd, 0xc4, 0x61, 0xab, 0x6b, 0x72, 0xf5, 0xb6, 0xa6, 0x14,
	0x92, 0xd5, 0x5c, 0x49, 0x16, 0x5a, 0x69, 0x52, 0x42, 0xa5, 0xce, 0xa4, 0x12, 0xeb, 0xb7, 0x7f,
	0x77, 0x91, 0x57, 0x8c, 0xd4, 0x54, 0xac, 0xc6, 0xd1, 0x9b, 0x90, 0x22, 0xac, 0xdb, 0xa7, 0x8e,
	0x83, 0xfb, 0x1c, 0x5b, 0xea, 0xaa, 0xa6, 0x14, 0xe2, 0x46, 0x92, 0xb0, 0xc6, 0xe4, 0x0a, 0xe5,
	0x20, 0x41, 0x58, 0x97, 0x3a, 0x5d, 0x93, 0xb8, 0x6a, 0x54, 0xd0, 0x63, 0x84, 0xb5, 0x9d, 0x1a,
	0x71, 0x51, 0x11, 0xd6, 0x47, 0x2e, 0x3e, 0x21, 0xf8, 0xb4, 0x4b, 0x6c, 0x73, 0x80, 0xbb, 0x63,
	0x77, 0xa8, 0xc6, 0x84, 0x9b, 0x6b, 0x3e, 0xa1, 0xe5, 0xdd, 0x1f, 0xb9, 0x43, 0xf4, 0x1e, 0x24,
	0xe9, 0x98, 0x8f, 0xc6, 0xbc, 0xcb, 0xcf, 0x46, 0x58, 0x8d, 0x6b, 0x4a, 0x21, 0x53, 0x55, 0xfd,
	0x18, 0xb5, 0x05, 0xc5, 0xff, 0xe9, 0x9c, 0x8d, 0xb0, 0x01, 0x34, 0xf8, 0xd6, 0xff, 0x12, 0x81,
	0xa8, 0x8c, 0xd3, 0x42, 0x6c, 0xde, 0x0a, 0xa5, 0x71, 0xe3, 0xe5, 0x8b, 0xfc, 0xda, 0x80, 0xba,
	0xf6, 0xbe, 0xce, 0xc8, 0x2f, 0xf0, 0x7e, 0xf5, 0xe1, 0x43, 0xdd, 0x0f, 0xd8, 0xdb, 0x10, 0xa7,
	0xa7, 0x0e, 0x76, 0xbb, 0xc4, 0x52, 0x6f, 0x69, 0x4a, 0x21, 0x5d, 0xcf, 0xbe, 0x7c, 0x91, 0x4f,
	0x49, 0x66, 0xe2, 0x58, 0xf8, 0xe7, 0xba, 0x11, 0x13, 0x1c, 0x2d, 0xeb, 0x6b, 0x12, 0xdd, 0x7b,
	0x10, 0x65, 0xdc, 0xc5, 0xa6, 0x2d, 0x42, 0x9a, 0xac, 0xa6, 0xfd, 0x60, 0x3d, 0x11, 0x97, 0x86,
	0x4f, 0x44, 0x3a, 0xac, 0x32, 0x6e, 0x72, 0x19, 0xd2, 0x64, 0x35, 0x15, 0x70, 0x99, 0x1c, 0x1b,
	0x92, 0xa4, 0xff, 0xf9, 0x16, 0x6c, 0x35, 0x5c, 0x1c, 0xa0, 0xc2, 0x57, 0xe1, 0x63, 0xa3, 0x06,
	0x09, 0xbf, 0x37, 0xdc, 0x10, 0xf3, 0x71, 0x29, 0xd6, 0xb2, 0x50, 0x15, 0x92, 0xe2, 0xd9, 0xb4,
	0x6b, 0x53, 0x4b, 0xa6, 0x23, 0x53, 0x5d, 0x0f, 0x5c, 0xf1, 0x28, 0x07, 0xd4, 0xc2, 0x06, 0xb0,
	0xe0, 0x1b, 0x3d, 0x00, 0x18, 0xb9, 0xf4, 0xa7, 0xb8, 0xef, 0xb5, 0x52, 0x91, 0x94, 0xa9, 0xc8,
	0xe3, 0x80, 0x60, 0xcc, 0x30, 0xa1, 0x26, 0x24, 0x8e, 0x5d, 0x61, 0x93, 0x63, 0x91, 0x94, 0x74,
	0xfd, 0xad, 0xcb, 0x8b, 0xfc, 0x6e, 0x76, 0x43, 0xcd, 0x17, 0xdf, 0x10, 0xf0, 0xed, 0x61, 0xad,
	0x87, 0xf9, 0x29, 0xc6, 0x8e, 0x56, 0xad, 0x68, 0xa6, 0x63, 0x69, 0xef, 0x54, 0xb4, 0xe3, 0x11,
	0x33, 0xa6, 0x92, 0xe8, 0x07, 0x10, 0xeb, 0x11, 0x2e, 0x94, 0xac, 0x0a, 0x25, 0x95, 0xcb, 0x8b,
	0xfc, 0xfd, 0xec, 0x6f, 0x0f, 0xd5, 0xbf, 0x3f, 0xbf, 0x55, 0xdc, 0x9d, 0xd7, 0xf3, 0xa0, 0x52,
	0xaa, 0x54, 0x2a, 0x3f, 0x14, 0xca, 0x1e, 0xca, 0x6f, 0x63, 0xa2, 0x00, 0xed, 0x00, 0xb8, 0x98,
	0xd1, 0xe1, 0x58, 0xbc, 0x22, 0x2a, 0x2a, 0x73, 0xe6, 0x06, 0x7d, 0x07, 0x32, 0xc4, 0x19, 0x60,
	0xe6, 0x1d, 0x64, 0xe9, 0xc7, 0xc4, 0x4b, 0xef, 0xf8, 0x2f, 0x6d, 0x4d, 0x88, 0xa2, 0xec, 0xd3,
	0x64, 0xf6, 0xa8, 0x7f, 0x0e, 0xdb, 0x41, 0xb3, 0x91, 0x39, 0xf3, 0x5b, 0x8e, 0x4c, 0xdc, 0xf6,
	0x42, 0xe2, 0x66, 0x52, 0x92, 0x87, 0x24, 0x75, 0x86, 0x67, 0x5d, 0xb3, 0xcf, 0xc9, 0x89, 0x4c,
	0x49, 0xdc, 0x00, 0xef, 0xaa, 0x26, 0x6e, 0xf4, 0x4f, 0x61, 0xbb, 0x41, 0xed, 0xd1, 0xb4, 0xa5,
	0x86, 0xab, 0xe2, 0x95, 0xca, 0xb7, 0x21, 0x21, 0xcb, 0xcf, 0x23, 0x7a, 0xaa, 0xd3, 0x46, 0x5c,
	0x5e, 0xb4, 0x2c, 0xfd, 0xd7, 0x31, 0x88, 0x4a, 0x5d, 0xe8, 0x61, 0x80, 0xd7, 0x74, 0xfd, 0xde,
	0xcb, 0x17, 0xf9, 0x37, 0x25, 0xe0, 0x46, 0x2e, 0xb1, 0x4d, 0xf7, 0xac, 0xfb, 0x14, 0x9f, 0xdd,
	0xaf, 0x1d, 0x75, 0xda, 0xdd, 0xd6, 0x61, 0xc3, 0x68, 0x1e, 0x34, 0x0f, 0x3b, 0xba, 0x80, 0xf5,
	0xde, 0xac, 0x6d, 0x89, 0xed, 0x45, 0xb8, 0x4e, 0xbd, 0xb9, 0x11, 0xb8, 0xbf, 0x07, 0xc0, 0xb8,
	0xe9, 0xf2, 0x9b, 0x21, 0x3b, 0xe1, 0xcb, 0xd4, 0x3c, 0xb8, 0x24, 0x8f, 0x89, 0x43, 0xd8, 0x57,
	0x52, 0xc3, 0xea, 0x35, 0x35, 0xc0, 0x44, 0xa8, 0xc6, 0xe7, 0xe1, 0x12, 0xbd, 0x39, 0x5c, 0x62,
	0xd7, 0x81, 0xcb, 0xdd, 0x59, 0xb8, 0xc4, 0x45, 0x96, 0x66, 0x50, 0xa0, 0x4e, 0x51, 0x90, 0x10,
	0xb4, 0x2b, 0x6a, 0x1a, 0x16, 0x6a, 0xfa, 0xbe, 0xd7, 0x99, 0x4c, 0x3e, 0x66, 0x6a, 0x32, 0x54,
	0xcb, 0x32, 0xe9, 0xa2, 0xf5, 0x8c, 0x99, 0xe1, 0xf3, 0x2c, 0x41, 0x40, 0xea, 0xda, 0x08, 0x40,
	0x55, 0x78, 0x6d, 0x2a, 0xec, 0x97, 0x9c, 0xe8, 0xf8, 0x69, 0xe1, 0xd5, 0x46, 0x40, 0x94, 0xb6,
	0x0f, 0x65, 0xaf, 0x5f, 0x9f, 0xca, 0x98, 0x96, 0xe5, 0x62, 0xc6, 0xd4, 0x8c, 0xe0, 0xcf, 0x06,
	0x84, 0x9a, 0xbc, 0x47, 0xef, 0x82, 0x3a, 0x65, 0xee, 0x99, 0xfd, 0xa7, 0xe3, 0x51, 0x20, 0xb3,
	0x26, 0x64, 0x36, 0x03, 0x7a, 0x5d, 0x90, 0x27, 0x92, 0x4b, 0xa7, 0x5f, 0x76, 0xf9, 0xf4, 0xdb,
	0x16, 0x7d, 0xde, 0x87, 0xe2, 0xba, 0x80, 0x62, 0x9c, 0x30, 0x09, 0xc4, 0x59, 0x45, 0x27, 0xc4,
	0xc2, 0x54, 0x28, 0x42, 0x21, 0x45, 0x9f, 0x78, 0xf7, 0x47, 0xee, 0x50, 0x2f, 0x79, 0xd0, 0x12,
	0x61, 0x4d, 0x42, 0xac, 0xfd, 0xe8, 0x51, 0xb7, 0xd6, 0x32, 0xb2, 0x2b, 0xde, 0xe1, 0xb1, 0xd1,
	0xfc, 0xa4, 0xd5, 0xfc, 0x34, 0xab, 0x20, 0x80, 0x68, 0xfb, 0x50, 0x10, 0x22, 0x7a, 0x09, 0x62,
	0x7e, 0xe3, 0x40, 0xbb, 0xe1, 0xfd, 0x64, 0x6e, 0x9c, 0xf8, 0x3b, 0xc9, 0x2f, 0x15, 0x50, 0xe5,
	0xfe, 0x24, 0x06, 0x48, 0x78, 0x89, 0xfa, 0x3f, 0x0c, 0x8a, 0x60, 0x5a, 0x45, 0xae, 0x9c, 0x56,
	0xc5, 0xef, 0x02, 0x4c, 0x0b, 0x1a, 0x6d, 0xc0, 0x5a, 0xf3, 0xe3, 0xa3, 0x96, 0xd1, 0x6c, 0x74,
	0x6a, 0x87, 0x1f, 0x1c, 0x7d, 0x54, 0xf3, 0xde, 0x9b, 0x83, 0xcd, 0x27, 0x07, 0xed, 0x76, 0xe7,
	0xc3, 0xee, 0x3c, 0x4d, 0x29, 0xee, 0x00, 0x4c, 0x21, 0x84, 0xe2, 0x70, 0xfb, 0xa0, 0x7d, 0xd8,
	0xce, 0xae, 0xa0, 0x28, 0x44, 0x3a, 0xf5, 0xac, 0x52, 0xdc, 0x82, 0x74, 0xa8, 0xe4, 0x3c, 0x16,
	0xa3, 0x73, 0xf0, 0x38, 0xbb, 0x52, 0xfd, 0x63, 0x6c, 0xb2, 0x91, 0x35, 0xbc, 0xff, 0x00, 0x4f,
	0xb0, 0x7b, 0x42, 0xfa, 0x18, 0xfd, 0x18, 0x32, 0xe1, 0x35, 0x19, 0xdd, 0xf5, 0xfd, 0x5e, 0xba,
	0x3d, 0xe7, 0xd2, 0xa1, 0xd5, 0x4f, 0xcf, 0xfd, 0xea, 0x1f, 0xff, 0xfe, 0x7d, 0xe4, 0x8e, 0xbe,
	0x26, 0xfe, 0x3e, 0x9c, 0x3c, 0x28, 0xcb, 0x68, 0xb0, 0x7d, 0xa5, 0x88, 0x3e, 0x86, 0x44, 0xd0,
	0xe1, 0xd1, 0xeb, 0xbe, 0xdc, 0xfc, 0x2e, 0x3c, 0xaf, 0xf0, 0xae, 0x50, 0xb8, 0x89, 0xee, 0xcc,
	0x29, 0x2c, 0x3f, 0x23, 0xd6, 0x39, 0xfa, 0x12, 0x52, 0xb3, 0x8b, 0x32, 0xca, 0xf9, 0xc2, 0x4b,
	0xb6, 0xe7, 0xdc, 0xe6, 0x42, 0xdb, 0x6a, 0x7a, 0x4b, 0xef, 0xc4, 0x42, 0x71, 0xb9, 0x85, 0xcf,
	0x20, 0x35, 0xbb, 0x63, 0x07, 0x16, 0x96, 0x2c, 0xde, 0xf3, 0xae, 0xe7, 0x85, 0xe2, 0xad, 0xdc,
	0x52, 0xc5, 0x5e, 0x40, 0xbe, 0x84, 0x4c, 0x78, 0xbf, 0x46, 0x57, 0xf8, 0x98, 0x7b, 0x63, 0x3e,
	0x5a, 0xa1, 0x75, 0x5c, 0x7f, 0x5d, 0x58, 0x5a, 0x47, 0xf3, 0x51, 0x47, 0x14, 0x52, 0x72, 0x17,
	0xf2, 0x67, 0x94, 0x36, 0xf1, 0xf0, 0xaa, 0x05, 0x29, 0x17, 0x86, 0x8a, 0x5e, 0x12, 0x9a, 0x0b,
	0xfa, 0xee, 0xc2, 0x1b, 0x02, 0x74, 0x9c, 0x97, 0x65, 0xaf, 0x12, 0x39, 0x3e, 0x85, 0x3b, 0xcb,
	0xa6, 0x38, 0xd2, 0xe7, 0x1f, 0xb0, 0x38, 0xe2, 0x73, 0x99, 0x90, 0x69, 0xa6, 0xbf, 0x2d, 0x6c,
	0xdf, 0x43, 0xd7, 0xb1, 0x8d, 0x7e, 0xa3, 0x40, 0x66, 0x32, 0xe2, 0xfd, 0xc7, 0x4e, 0x6c, 0xbe,
	0x62, 0xf2, 0x5f, 0x59, 0x14, 0xdf, 0x17, 0xb6, 0xf7, 0xf5, 0x77, 0xaf, 0x61, 0xbb, 0xfc, 0x2c,
	0xd8, 0x0f, 0xce, 0xcb, 0x7d, 0xdf, 0x18, 0x7a, 0x1f, 0xd2, 0x06, 0xb6, 0x29, 0xc7, 0x0d, 0xea,
	0x70, 0x97, 0x0e, 0x51, 0x3e, 0x54, 0x39, 0x8b, 0x2d, 0x27, 0x17, 0x6a, 0x10, 0xfa, 0x4a, 0x41,
	0xa9, 0x28, 0xf5, 0xad, 0xbf, 0x5e, 0xee, 0x28, 0x7f, 0xbb, 0xdc, 0x51, 0xfe, 0x79, 0xb9, 0xa3,
	0xfc, 0xe1, 0x5f, 0x3b, 0x2b, 0x1f, 0x2a, 0x9f, 0xc9, 0xff, 0xe9, 0xbd, 0xa8, 0xf8, 0x79, 0xe7,
	0x3f, 0x01, 0x00, 0x00, 0xff, 0xff, 0xf3, 0xbf, 0x26, 0x10, 0xcb, 0x0f, 0x00, 0x00,
}
